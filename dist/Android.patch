--- orig/shell.c	2019-09-29 17:24:23.354739708 -0700
+++ shell.c	2019-09-29 17:24:23.552743588 -0700
@@ -87,6 +87,12 @@
 #endif
 #include <ctype.h>
 #include <stdarg.h>
+// Begin Android Add
+#ifndef NO_ANDROID_FUNCS
+#include <aicu/AIcu.h>
+#include <sqlite3_android.h>
+#endif
+// End Android Add
 
 #if !defined(_WIN32) && !defined(WIN32)
 # include <signal.h>
@@ -12702,6 +12708,21 @@
     sqlite3_create_function(p->db, "edit", 2, SQLITE_UTF8, 0,
                             editFunc, 0, 0);
 #endif
+// Begin Android Add
+#ifndef NO_ANDROID_FUNCS
+    AIcu_initializeIcuOrDie();
+    int err = register_localized_collators(p->db, "en_US", 0);
+    if (err != SQLITE_OK) {
+      fprintf(stderr, "register_localized_collators() failed\n");
+      exit(1);
+    }
+    err = register_android_functions(p->db, 0);
+    if (err != SQLITE_OK) {
+      fprintf(stderr, "register_android_functions() failed\n");
+      exit(1);
+    }
+#endif
+// End Android Add
     if( p->openMode==SHELL_OPEN_ZIPFILE ){
       char *zSql = sqlite3_mprintf(
          "CREATE VIRTUAL TABLE zip USING zipfile(%Q);", p->zDbFilename);
--- orig/sqlite3.c	2019-09-29 17:24:23.532743197 -0700
+++ sqlite3.c	2019-09-29 17:24:23.663745764 -0700
@@ -32502,6 +32502,10 @@
 # include <sys/mount.h>
 #endif
 
+#if defined(__BIONIC__)
+# include <android/fdsan.h>
+#endif
+
 #ifdef HAVE_UTIME
 # include <utime.h>
 #endif
@@ -33261,6 +33265,12 @@
 #if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)
     osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);
 #endif
+
+#if defined(__BIONIC__) && __ANDROID_API__ >= __ANDROID_API_Q__
+    uint64_t tag = android_fdsan_create_owner_tag(
+        ANDROID_FDSAN_OWNER_TYPE_SQLITE, fd);
+    android_fdsan_exchange_owner_tag(fd, 0, tag);
+#endif
   }
   return fd;
 }
@@ -33841,7 +33851,13 @@
 ** and move on.
 */
 static void robust_close(unixFile *pFile, int h, int lineno){
+#if defined(__BIONIC__) && __ANDROID_API__ >= __ANDROID_API_Q__
+  uint64_t tag = android_fdsan_create_owner_tag(
+      ANDROID_FDSAN_OWNER_TYPE_SQLITE, h);
+  if( android_fdsan_close_with_tag(h, tag) ){
+#else
   if( osClose(h) ){
+#endif
     unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",
                        pFile ? pFile->zPath : 0, lineno);
   }
@@ -36374,7 +36390,7 @@
   SimulateIOError( rc=1 );
   if( rc!=0 ){
     storeLastErrno((unixFile*)id, errno);
-    return SQLITE_IOERR_FSTAT;
+    return unixLogError(SQLITE_IOERR_FSTAT, "fstat", ((unixFile*)id)->zPath);
   }
   *pSize = buf.st_size;
 
@@ -36410,7 +36426,7 @@
     struct stat buf;              /* Used to hold return values of fstat() */
    
     if( osFstat(pFile->h, &buf) ){
-      return SQLITE_IOERR_FSTAT;
+      return unixLogError(SQLITE_IOERR_FSTAT, "fstat", pFile->zPath);
     }
 
     nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
@@ -37096,7 +37112,7 @@
     ** with the same permissions.
     */
     if( osFstat(pDbFd->h, &sStat) ){
-      rc = SQLITE_IOERR_FSTAT;
+      rc = unixLogError(SQLITE_IOERR_FSTAT, "fstat", pDbFd->zPath);
       goto shm_open_err;
     }
 
@@ -54268,15 +54284,9 @@
   unsigned pgFlags      /* Various flags */
 ){
   unsigned level = pgFlags & PAGER_SYNCHRONOUS_MASK;
-  if( pPager->tempFile ){
-    pPager->noSync = 1;
-    pPager->fullSync = 0;
-    pPager->extraSync = 0;
-  }else{
-    pPager->noSync =  level==PAGER_SYNCHRONOUS_OFF ?1:0;
-    pPager->fullSync = level>=PAGER_SYNCHRONOUS_FULL ?1:0;
-    pPager->extraSync = level==PAGER_SYNCHRONOUS_EXTRA ?1:0;
-  }
+  pPager->noSync = 1;
+  pPager->fullSync = 0;
+  pPager->extraSync = 0;
   if( pPager->noSync ){
     pPager->syncFlags = 0;
   }else if( pgFlags & PAGER_FULLFSYNC ){
@@ -55635,18 +55645,11 @@
   pPager->memDb = (u8)memDb;
   pPager->readOnly = (u8)readOnly;
   assert( useJournal || pPager->tempFile );
-  pPager->noSync = pPager->tempFile;
-  if( pPager->noSync ){
-    assert( pPager->fullSync==0 );
-    assert( pPager->extraSync==0 );
-    assert( pPager->syncFlags==0 );
-    assert( pPager->walSyncFlags==0 );
-  }else{
-    pPager->fullSync = 1;
-    pPager->extraSync = 0;
-    pPager->syncFlags = SQLITE_SYNC_NORMAL;
-    pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);
-  }
+  pPager->noSync = 1;
+  assert( pPager->fullSync==0 );
+  assert( pPager->extraSync==0 );
+  assert( pPager->syncFlags==0 );
+  assert( pPager->walSyncFlags==0 );
   /* pPager->pFirst = 0; */
   /* pPager->pFirstSynced = 0; */
   /* pPager->pLast = 0; */
@@ -106558,7 +106561,7 @@
 #endif
     sqlite3BtreeLeave(pNew->pBt);
   }
-  pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
+  pNew->safety_level = 1;
   if( rc==SQLITE_OK && pNew->zDbSName==0 ){
     rc = SQLITE_NOMEM_BKPT;
   }
@@ -124505,7 +124508,7 @@
   }
   if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){
     sqlite3SetString(pzErrMsg, db, "unsupported file format");
-    rc = SQLITE_ERROR;
+    rc = SQLITE_CORRUPT_BKPT; // Android Change from "rc = SQLITE_ERROR;";
     goto initone_error_out;
   }
 
@@ -158412,7 +158415,7 @@
   ** database it is OFF. This matches the pager layer defaults.  
   */
   db->aDb[0].zDbSName = "main";
-  db->aDb[0].safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
+  db->aDb[0].safety_level = 1;
   db->aDb[1].zDbSName = "temp";
   db->aDb[1].safety_level = PAGER_SYNCHRONOUS_OFF;
 
@@ -164895,13 +164898,25 @@
   ** module with sqlite.
   */
   if( SQLITE_OK==rc 
+#ifndef ANDROID    /* fts3_tokenizer disabled for security reasons */
    && SQLITE_OK==(rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))
+#endif
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "snippet", -1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "offsets", 1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 2))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "optimize", 1))
   ){
+#ifdef SQLITE_ENABLE_FTS3_BACKWARDS
+    rc = sqlite3_create_module_v2(
+        db, "fts1", &fts3Module, (void *)pHash, 0
+        );
+    if(rc) return rc;
+    rc = sqlite3_create_module_v2(
+        db, "fts2", &fts3Module, (void *)pHash, 0
+        );
+    if(rc) return rc;
+#endif
     rc = sqlite3_create_module_v2(
         db, "fts3", &fts3Module, (void *)pHash, hashDestroy
     );
